#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

#include "cmsis_os2.h"
#include "ohos_init.h"

#include <dtls_al.h>
#include <mqtt_al.h>
#include <oc_mqtt_al.h>
#include <oc_mqtt_profile.h>


#include "wifi_connect.h"

// 关于GPIO以及ADC的头文件
#include "iot_adc.h"
#include "iot_errno.h"

#include "iot_gpio_ex.h"
#include "iot_gpio.h"
#include "hi_gpio.h"
// I2C相关的头文件以及函数
#include "hi_i2c.h"
#include "iot_i2c.h"
#include "iot_i2c_ex.h"
// #include "MPU9250.h"
#include "hi_time.h"
#include "iot_errno.h"

#include "MPU9250.h"
#include "MPU92502.h"

// float q[4]; /* 四元数*/
// float yprf[3];   /* yaw/pitch/roll*/
unsigned char dmpdatas[42];

const unsigned char dmpmemorydata[1929]={
 // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

const unsigned char dmpcfgupddata[239] = {
//  dmp config 
//  BANK    OFFSET  LENGTH  [DATA]
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,         
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,         
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,   
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,   
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, 
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,         
    0x00,   0x6C,   0x02,   0x20, 0x00,               
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,  
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,  
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,  
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,  
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,         
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,   
    0x00,   0xA3,   0x01,   0x00,                    
    0x00,   0x00,   0x01,   0x01, 
    
    //0x00,   0x00,   0x00,   0x01,  ?LENGTH=0x00,??
        
    0x07,   0x86,   0x01,   0xFE,                     
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, 
    0x07,   0x7E,   0x01,   0x30,                   
    0x07,   0x46,   0x01,   0x9A,                    
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,   
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,  
    0x02,   0x16,   0x02,   0x00, 0x00,              
// FIFO rate :0x00=200HZ,0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ, 

//dmp updates
    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
};

     int16_t ACC_X;		//寄存器读取的16位数据
     int16_t ACC_Y;
     int16_t ACC_Z;
     int16_t Gyro_X;
     int16_t Gyro_Y;
     int16_t Gyro_Z;	
     int16_t TACC_X;		//测试寄存器读取的16位数据
     int16_t TACC_Y;
     int16_t TACC_Z;
     int16_t TGyro_X;
     int16_t TGyro_Y;
     int16_t TGyro_Z;	
     int16_t Mag_X;
     int16_t Mag_Y;
     int16_t Mag_Z;
     int16_t Mag_X_min;
     int16_t Mag_X_max;
     int16_t Mag_Y_min;
     int16_t Mag_Y_max;
     int16_t GXST,AXST;
     int16_t GYST,AYST;
     int16_t GZST,AZST;
     int16_t MXST;
     int16_t MYST;
     int16_t MZST;
     int8_t  GXT,AXT;
     int8_t  GYT,AYT;
     int8_t  GZT,AZT;
     int16_t GXOFF;
     int16_t GYOFF;
     int16_t GZOFF;
     float AccX;
     float AccY;
     float AccZ;
     float GyroX;
     float GyroY;
     float GyroZ;
     float Mag_X_uT;
     float Mag_Y_uT;
     float Mag_Z_uT;
     float destination[6];

     float q[4]; /* 四元数*/
     float yprf[3];   /* yaw/pitch/roll*/

/*
* @brief MPU9250通信IIC相关功能的初始化
*/
static void MPU9250IoInit(void)
{
    IoTGpioInit(HI_GPIO_IDX_0);
    IoTGpioSetFunc(HI_GPIO_IDX_0, IOT_GPIO_FUNC_GPIO_0_I2C1_SDA);
    // IoTGpioSetDir
    IoTGpioInit(HI_GPIO_IDX_1);
    IoTGpioSetFunc(HI_GPIO_IDX_1, IOT_GPIO_FUNC_GPIO_1_I2C1_SCL);

    IoTI2cInit(HI_I2C_IDX_1, 400000);
}

/*
 * @brief 读取元器件传回来的值
 * @param addr IIC通信地址
 * @param reg 要操作的寄存器的地址
 * @param Value 要在寄存器中写入的值
*/
static int I2CWriteByte(uint8_t addr,uint8_t Reg, uint8_t Value){
    uint32_t ret;
    uint8_t send_date[2] = { Reg, Value };
    ret = IoTI2cWrite(HI_I2C_IDX_1, (addr << 1) | 0x00, send_date, sizeof(send_date));
    if (ret != 0)
    { 
        printf("IIC_Write ret = %x\r\n", ret);
        return ret;
    }
    return 0;
}

/*
 * @brief 读取元器件传回来的值
 * @param addr IIC通信地址
 * @param reg 要操作的寄存器的地址
 * @param length 接收数据的长度
 * @param pBuffer 要存储数据的地址
*/
static int I2CRead(uint8_t addr, uint8_t Reg,  uint16_t Length, uint8_t *pBuffer)
{
    IotI2cData mpu9250data = {0};
    uint8_t buffer[1] = { Reg };
    mpu9250data.sendBuf = buffer;
    mpu9250data.sendLen = 1;
    mpu9250data.receiveBuf = pBuffer;
    mpu9250data.receiveLen = Length;
    int ret = IoTI2cWriteread(HI_I2C_IDX_1, (addr << 1) | 0x00, &mpu9250data);
    if(ret != 0) {
        printf("===== Error: I2C writeread ret = 0x%x! =====\r\n", ret);
        return ret;
    }
    return 0;
}

// 存储数据的地址
typedef struct 
{
    short ACC_X1;
    short ACC_Y1;
    short ACC_Z1;
    short Gyro_X1;
    short Gyro_Y1;
    short Gyro_Z1;
    short Mag_X1;
    short Mag_Y1;
    short Mag_Z1;
} MPU9250_AC_date;


int mpuconfig(void)
{

    I2CWriteByte(MPU9250_ADDRESS, 0x6B, 0x80); //重置寄存器
    hi_udelay(100000);
    I2CWriteByte(MPU9250_ADDRESS,0x1C,ACC_FULL_SCALE_2_G);//设置重力计单位值
    I2CWriteByte(MPU9250_ADDRESS,0x1B,GYRO_FULL_SCALE_250_DPS);//设置陀螺仪单位值
    I2CWriteByte(MPU9250_ADDRESS,0x37,0x02);//设置旁路模式
    I2CWriteByte(MAG_ADDRESS,0x0A,0x11);//设置磁力计通讯模式

}

int readAG(void)	//读取加速度和陀螺仪的数据
{
    uint8_t Buf[14];
    I2CRead(MPU9250_ADDRESS, 0x3B, 14, Buf);

    // 加速度
     ACC_X = (Buf[0] << 8) | Buf[1];
     ACC_Y = (Buf[2] << 8) | Buf[3];
     ACC_Z = (Buf[4] << 8) | Buf[5];

    // 陀螺仪
     Gyro_X = (Buf[8] << 8) | Buf[9];
     Gyro_Y = (Buf[10] << 8) | Buf[11];
     Gyro_Z = (Buf[12] << 8) | Buf[13];

    // 修正printf语句
    printf("%d %d %d %d %d %d\r\n", ACC_X, ACC_Y, ACC_Z, Gyro_X, Gyro_Y, Gyro_Z);
}

int readMag(void)
{ 
    /*
    uint8_t Buf[6];	
    I2CRead(MAG_ADDRESS,0x10,3,Buf);  //读取磁力计数据

    Mag_X=(Buf[1]<<8 | Buf[0]);
    Mag_Y=(Buf[3]<<8 | Buf[2]);
    Mag_Z=-(Buf[5]<<8 | Buf[4]);
    */
    uint8_t rawData[6];  // x/y/z gyro calibration data stored here
    //   I2CWriteByte(MPU9250_ADDRESS, 0x37, 0x02); // Power down magnetometer  
    //   I2CWriteByte(MAG_ADDRESS, 0x0A, 0x01); // Enter Fuse ROM access mode
    I2CRead(MAG_ADDRESS, 0x10, 3, rawData);
     Mag_X =  (rawData[0]<<8 | rawData[1]);   
     Mag_Y =  (rawData[2]<<8 | rawData[3]);
     Mag_Z =  (rawData[4]<<8 | rawData[5]);
    printf("%d %d %d \r\n",Mag_X, Mag_Y,Mag_Z);
    //   I2CWriteByte(MAG_ADDRESS, 0x0A, 0x00); // Power down magnetometer  
    hi_udelay(10000);
}


//磁力计自测模式
int magselftest(void)
{
	uint8_t Buf[6];
	I2CWriteByte(0x18, 0x0C, 0x40); //开启磁力计自测模式
	I2CRead(0x18,0x00,1,Buf);       //读取数据是否准备妥当
	MZST=Buf[0];
	I2CWriteByte(0x18, 0x0A, 0x08); //开启自测模式
	I2CRead(0x18,0x0A,1,Buf);       //读取数据是否准备妥当
	MYST=Buf[0];
	I2CRead(0x18,0x02,1,Buf);       //读取数据是否准备妥当
	MXST=Buf[0];
	// if(Buf[0]==0x01)
	// {
		// I2CRead(MPU9250_ADDRESS,0x03,6,Buf);
		// MXST = Buf[0]<<8 | Buf[1] ;
		// MYST = Buf[2]<<8 | Buf[3] ;
		// MZST = Buf[4]<<8 | Buf[5] ;
	// }
	I2CWriteByte(0x18, 0x0C, 0x00); //关闭自测模式
	
}

//读自检数据
int readST(void)
{
    uint8_t Buf[3];
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_ACCEL_CONFIG, 0x00);  
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_GYRO_CONFIG,  0x00);  
    hi_udelay(50000); 
    I2CRead(MPU9250_ADDRESS,0x00,3,Buf);
    GXT=Buf[0];
    GYT=Buf[1];
    GZT=Buf[2];
}


int MAG_uT(void)//磁力计转换
{
    Mag_X_uT = (Mag_X * 0.15 * 1.171875 + 0.5)/10;
    Mag_Y_uT = (Mag_Y * 0.15 * 1.175781 - 231)/10;
    //Mag_Z_uT = Mag_Z * 0.15 * 1.136719;
}

int findmix(void)//确定最大值与最小值
{
    if(Mag_X_max<Mag_X_uT)Mag_X_max=Mag_X_uT;//比较出测量的最大值
    if(Mag_Y_max<Mag_Y_uT)Mag_Y_max=Mag_Y_uT;
    if(Mag_X_min>Mag_X_uT)Mag_X_min=Mag_X_uT;//比较出测量的最小值
    if(Mag_Y_min>Mag_Y_uT)Mag_Y_min=Mag_Y_uT;
}

int Offsetget(void)//偏移量检测
{
	uint8_t Buf[6];
	int16_t gAvg[3];
	I2CRead(MPU9250_ADDRESS, 0x13, 6, Buf);
	
	gAvg[0]= Buf[1]<<8 | Buf[0];
	gAvg[0]= Buf[2]<<8 | Buf[3];
	gAvg[0]= Buf[4]<<8 | Buf[5];
	
	GXOFF=gAvg[0];
	GYOFF=gAvg[1];
	GZOFF=gAvg[2];
}

int SelfTest(void)//芯片自测
{
    uint8_t Buf[14];
    uint8_t selfTest[3];
    int32_t gAvg[3], aAvg[3], aSTAvg[3], gSTAvg[3];
    float factoryTrim[6];
    uint8_t FS = 0;

    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_SMPLRT_DIV, 0x00);  //设置陀螺仪采样率不分频
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_CONFIG, 0x02); //设置陀螺仪采样率1KHz而 DLPF为32KHz   
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_GYRO_CONFIG, 0x00); //设置陀螺仪采样范围为250°/s
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_ACCEL_CONFIG_2, 0x06); //设置加速度采样率为1KHz，带宽为32KHz
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_ACCEL_CONFIG, 0x00); //设置加速度采样范围2G

    for( int ii = 0; ii < 200; ii++) //读200次加速度计和陀螺仪数值并取平均
    { 
        I2CRead(MPU9250_ADDRESS, 0x3B, 14, Buf);        
        aAvg[0] += ((Buf[0] << 8) | Buf[1]); 
        aAvg[1] += ((Buf[2] << 8) | Buf[3]) ; 
        aAvg[2] += ((Buf[4] << 8) | Buf[5]) ; 
            
        gAvg[0] += ((Buf[8] << 8) | Buf[9]) ; 
        gAvg[1] += ((Buf[10] << 8) | Buf[11]) ;  
        gAvg[2] += ((Buf[12] << 8) | Buf[13]) ; 
    }

    for (int ii =0; ii < 3; ii++) 
    {
        aAvg[ii] /= 200;
        gAvg[ii] /= 200;
    }
    /*******************普通模式数据***********************************/
    ACC_X=aAvg[0];ACC_Y=aAvg[1];ACC_Z=aAvg[2];
    Gyro_X=gAvg[0];Gyro_Y=gAvg[1];Gyro_Z=gAvg[2];
    /******************************************************************/
    /*配置并使能加速度计和陀螺仪自检模式，范围2G和250°/s*/
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_ACCEL_CONFIG, 0xE0); 
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_GYRO_CONFIG,  0xE0);
    hi_udelay(25000);

    for( int ii = 0; ii < 200; ii++) //读加速度和陀螺仪自检数值并计算200次平均值
    {
        I2CRead(MPU9250_ADDRESS, 0x3B, 14, Buf); 
        aSTAvg[0] += ((Buf[0] << 8) | Buf[1]) ; 
        aSTAvg[1] += ((Buf[2] << 8) | Buf[3]) ;  
        aSTAvg[2] += ((Buf[4] << 8) | Buf[5]) ;

        gSTAvg[0] += ((Buf[8] << 8) | Buf[9]) ;
        gSTAvg[1] += ((Buf[10] << 8) | Buf[11]) ;  
        gSTAvg[2] += ((Buf[12] << 8) | Buf[13]) ; 
    }

    for (int ii =0; ii < 3; ii++)
    {
        aSTAvg[ii] /= 200;
        gSTAvg[ii] /= 200;
    } 
        
    // /*******************自检模式数据***********************************/  

    TACC_X=aSTAvg[0];TACC_Y=aSTAvg[1];TACC_Z=aSTAvg[2];
    TGyro_X=gSTAvg[0];TGyro_Y=gSTAvg[1];TGyro_Z=gSTAvg[2];
    // /******************************************************************/

    /*计算差值*/
    AXST=aSTAvg[0]-aAvg[0];
    AYST=aSTAvg[1]-aAvg[1];
    AZST=aSTAvg[2]-aAvg[2];
    GXST=gSTAvg[0]-gAvg[0];
    GYST=gSTAvg[1]-gAvg[1];
    GZST=gSTAvg[2]-gAvg[2];

    // /*配置加速度计和陀螺仪回到正常模式（初始化）*/
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_ACCEL_CONFIG, 0x00);  
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_GYRO_CONFIG,  0x00);  
    hi_udelay(25000); 

    // /**************读取传感器自测寄存器数值***************************/
    I2CRead(MPU9250_ADDRESS,0x0D,3,selfTest);
    AXT=selfTest[0];
    AYT=selfTest[1];
    AZT=selfTest[2];

    I2CRead(MPU9250_ADDRESS,0x00,3,selfTest);
    GXT=selfTest[0];
    GYT=selfTest[1];
    GZT=selfTest[2];
    // /*****************************************************************/

    //计算工厂偏移值，注意，这里计算出来的是出场数据的偏移值，也就是标准偏移量。
    factoryTrim[0] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)AXT - 1.0) ));
    factoryTrim[1] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)AYT - 1.0) )); 
    factoryTrim[2] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)AZT - 1.0) )); 
    factoryTrim[3] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)GXT - 1.0) )); 
    factoryTrim[4] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)GYT - 1.0) ));
    factoryTrim[5] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)GZT - 1.0) ));


    //在得到标准的偏移量后，可以通过（（自测模式读取值-正常模式读取值）/工厂标准偏移值）*100%的方法检测传感器和出场值偏移了百分之多少。
    for (int i = 0; i < 3; i++)
    {
        destination[i]=100.0*((float)(aSTAvg[i] - aAvg[i]))/factoryTrim[i];
        destination[i+3]=100.0*((float)(gSTAvg[i] - gAvg[i]))/factoryTrim[i+3];
    }
}

//读取FIFO计数的值
uint16_t getFIFOCount(void)
{
	uint8_t buffer[2] = {0};
	I2CRead(MPU9250_ADDRESS, MPU9250_RA_FIFO_COUNTH, 2, buffer);
	return (((uint16_t)buffer[0]) << 8) | buffer[1];		
}

//重置FIFO计数
int resetFIFO(void)
{
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_FIFO_RESET_BIT);
}

//配置模式选择
//ways = 1 选择普通配置
//ways = 2 选择DMP配置
int mpuDMPconfig(void)
{
    
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_PWR_MGMT_1, 0x80);//pw1	
    hi_udelay(100000);  
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_PWR_MGMT_1, 0x00);//pw1	
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_PWR_MGMT_2, 0x00);//pw2	

    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_SMPLRT_DIV, 0x04);//1000/50 = 20hz
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_CONFIG, 0x06); //1KHZ
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_GYRO_CONFIG, 0x18);//+- 2000
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_ACCEL_CONFIG, 0x10);//+- 4g

    //设置MPU9250中断,如不需要就无需设置
    // MPU9250_INT_init();

    /***********************DMP 的配置(开启DMP ，设置DMP FIFO)***************************/
    loadfirmware(); 
    loadcfgupd();

    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_DMP_CFG_1 , 0x03);
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_DMP_CFG_2 , 0x00);
    I2CWriteByte(MPU9250_ADDRESS,MPU9250_RA_USER_CTRL , 0xcc);
    /********************************************************/  	
    return 0;
}


int loadfirmware(void)
{
    unsigned int datanum=0;
    unsigned char bank;
    unsigned lastbank=1;
    for (datanum=0;datanum<1929;datanum++)
    {
        bank=datanum/256;
        if(lastbank!=bank)
        {
        I2CWriteByte(MPU9250_ADDRESS,0x6d,bank);
        I2CWriteByte(MPU9250_ADDRESS,0x6e,0);
        }

        I2CWriteByte(MPU9250_ADDRESS,0x6f,dmpmemorydata[datanum]);  
        lastbank=bank; 
    }
}

int loadcfgupd(void)
{
    unsigned char line;
    unsigned char bank;
    unsigned char datacounts=0;
    unsigned char bytes2write;
    unsigned char offset;
    unsigned char writingcounts;
        
    for (line=0;line<37;line++)
    {
        bank=dmpcfgupddata[datacounts];
        datacounts++;
        offset=dmpcfgupddata[datacounts];
        datacounts++;
        bytes2write=dmpcfgupddata[datacounts];

        I2CWriteByte(MPU9250_ADDRESS,0x6d,bank);  
        I2CWriteByte(MPU9250_ADDRESS,0x6e,offset);
        for (writingcounts=0;writingcounts<bytes2write;writingcounts++)
        {
            datacounts++;

            I2CWriteByte(MPU9250_ADDRESS,0x6f,dmpcfgupddata[datacounts]);  
        }
        datacounts++;
    }
}


/************************************/
/*
姿态计算
*/
/************************************/
int getyawpitchroll(void)//计算欧拉角
{
  getquaternion();//计算四元数
	yprf[0]=-atan2(2.0*(q[0]*q[3] + q[1]*q[2]),
	                     1 - 2.0*(q[2]*q[2] + q[3]*q[3]))*57.3;  //yaw	
	yprf[1]=-asin(2.0*(q[0]*q[2] - q[3]*q[1]))*57.3;//pitch
	yprf[2] = atan2(2.0*(q[0]*q[1] + q[2]*q[3]),
	                       1 - 2.0*(q[1]*q[1] + q[2]*q[2]))*57.3; //roll
}

int getquaternion(void)//提取四元数
{    
    q[0] = getdmplong(0)/1073741824.0;  
    q[1] = getdmplong(4)/1073741824.0;
    q[2] = getdmplong(8)/1073741824.0;
    q[3] = getdmplong(12)/1073741824.0;
}

/************************************/
/*
DMP 数据处理
*/
/************************************/
int ReadDmp(void)//读取DMP的值，保存在dmpdatas数组中
{
    I2CRead(MPU9250_ADDRESS, 0x74, 42, dmpdatas);//读取DMP中42个数据
    I2CWriteByte(MPU9250_ADDRESS, MPU9250_RA_USER_CTRL, 0xcc);//FIFO_RST | DMP_RST | DMP_EN | FIFO_EN 
}

long getdmplong(unsigned char address)//dmp数据合并
{
    long dmptempl;
    dmptempl = dmpdatas[address];
    dmptempl <<= 8;
    dmptempl |= dmpdatas[address+1];
    dmptempl <<= 8;
    dmptempl |= dmpdatas[address+2];
    dmptempl <<= 8;
    dmptempl |= dmpdatas[address+3];
    return dmptempl;
}

